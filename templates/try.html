<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ultra Reorderable List (single file)</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#6ad1ff; --muted:#9aa7b2;
    --item-bg:#0f1a2b;
  }
  html,body{height:100%; margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,#09111a 0%, #07101a 100%); color: #e6eef6;}
  .wrap{max-width:900px;margin:32px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.6);}
  h1{margin:0 0 8px;font-weight:600;font-size:20px}
  p.lead{margin:0 0 18px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 12px;border-radius:8px;cursor:pointer}
  button.secondary{color:var(--muted);border-color:rgba(255,255,255,0.04)}
  .listcard{background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.006));padding:12px;border-radius:10px}
  ul.reorder-list{list-style:none;padding:8px;margin:0;display:block;max-height:520px;overflow:auto}
  ul.reorder-list li{
    display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;margin:6px 2px;background:var(--item-bg);border:1px solid rgba(255,255,255,0.02);
    transition:transform 160ms ease, box-shadow 120ms ease, background 160ms;
    touch-action:none; user-select:none;
  }
  li .content{flex:1;display:flex;flex-direction:column}
  li .title{font-weight:600}
  li .meta{font-size:12px;color:var(--muted);margin-top:4px}
  .handle{
    width:38px;height:38px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;border:1px dashed rgba(255,255,255,0.03);
    cursor:grab;background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);
  }
  .handle:active{cursor:grabbing}
  .ghost{position:fixed;pointer-events:none;z-index:9999;transform:rotate(-3deg);opacity:.95;box-shadow:0 12px 30px rgba(2,6,23,0.6);width:var(--ghost-w);}
  .placeholder{
    height:56px;border-radius:8px;margin:6px 2px;background:linear-gradient(90deg, rgba(106,209,255,0.06), rgba(255,255,255,0.02));
    border:1px dashed rgba(106,209,255,0.18);
    transition:height 120ms ease;
  }
  .li-dragging{opacity:.25;transform:scale(0.98);box-shadow:none}
  .kbd-focus{outline:3px solid rgba(106,209,255,0.12);outline-offset:2px}
  .hint{font-size:13px;color:var(--muted);margin-top:10px}
  @media (max-width:520px){ .wrap{margin:12px} li{padding:10px} .handle{width:36px;height:36px}}
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="Ultra reorder example">
  <h1>Ultra Reorderable List</h1>
  <p class="lead">Drag items by the handle (or long-press on touch). Use keyboard (focus an item and press ↑ / ↓) to reorder. Order is saved in localStorage.</p>

  <div class="controls">
    <button id="resetBtn" class="secondary" title="Reset to original order">Reset</button>
    <button id="exportBtn" title="Export current order as JSON">Export JSON</button>
    <div style="flex:1"></div>
    <div style="color:var(--muted);font-size:13px">Double-click an item to edit label</div>
  </div>

  <div class="listcard">
    <ul id="reorderList" class="reorder-list" role="listbox" aria-label="Reorderable items">
      <!-- Items will be injected by JS -->
    </ul>
    <div class="hint">Tip: Try on mobile — long-press the handle to start drag. Items animate into place.</div>
  </div>
</div>

<script>
/*
 Ultra Reorder - single-file vanilla JS
 Features:
  - Pointer drag (mouse + touch via pointer events)
  - Keyboard reorder (ArrowUp / ArrowDown)
  - Drag handle
  - Ghost element following pointer, placeholder insertion
  - localStorage persistence
  - Double-click edit, Export JSON
*/

(() => {
  // Initial items
  const initial = [
    {id:'a',title:'Design homepage',meta:'Due: Oct 20 • High'},
    {id:'b',title:'Write unit tests',meta:'Due: Oct 21 • Medium'},
    {id:'c',title:'Implement reorder widget',meta:'Due: Oct 22 • High'},
    {id:'d',title:'Accessibility review',meta:'Due: Oct 25 • Low'},
    {id:'e',title:'Finalize styles',meta:'Due: Oct 23 • Medium'},
    {id:'f',title:'Deploy to staging',meta:'Due: Oct 26 • High'},
  ];

  const KEY = 'ultra-reorder-order-v1';
  const listEl = document.getElementById('reorderList');

  // load from storage or default
  const saved = (() => {
    try {
      const raw = localStorage.getItem(KEY);
      if (!raw) return initial;
      const parsed = JSON.parse(raw);
      // basic validation
      if (!Array.isArray(parsed) || !parsed.length) return initial;
      return parsed;
    } catch(e) { return initial; }
  })();

  // Render items
  function render(items){
    listEl.innerHTML = '';
    for(const item of items){
      const li = document.createElement('li');
      li.className = 'rli';
      li.tabIndex = 0;
      li.setAttribute('role','option');
      li.setAttribute('data-id', item.id);
      li.innerHTML = `
        <div class="handle" aria-hidden="true" title="Drag handle" data-handle>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6" d="M10 6h8M10 12h8M10 18h8M6 6h.01M6 12h.01M6 18h.01"></path></svg>
        </div>
        <div class="content">
          <div class="title">${escapeHtml(item.title)}</div>
          <div class="meta">${escapeHtml(item.meta || '')}</div>
        </div>
      `;
      // attach dblclick listener for inline edit
      li.addEventListener('dblclick', ()=> inlineEdit(li));
      listEl.appendChild(li);
    }
    attachBehaviors();
  }

  // escape helper
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // Save order (serialize current items)
  function saveOrder(){
    const arr = Array.from(listEl.children).map(li => {
      return {
        id: li.dataset.id,
        title: li.querySelector('.title').textContent,
        meta: li.querySelector('.meta').textContent
      };
    });
    localStorage.setItem(KEY, JSON.stringify(arr));
  }

  // Inline edit
  function inlineEdit(li){
    const titleEl = li.querySelector('.title');
    const old = titleEl.textContent;
    const input = document.createElement('input');
    input.value = old;
    input.style.width = '100%';
    input.style.fontSize = '15px';
    input.style.padding = '6px';
    titleEl.replaceWith(input);
    input.focus();
    input.select();
    function finish(save){
      const newEl = document.createElement('div');
      newEl.className = 'title';
      newEl.textContent = save ? input.value.trim() || old : old;
      input.replaceWith(newEl);
      saveOrder();
    }
    input.addEventListener('blur',()=> finish(true));
    input.addEventListener('keydown', (e)=> {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
      if (e.key === 'Escape') { finish(false); }
    });
  }

  // Export button
  document.getElementById('exportBtn').addEventListener('click', ()=>{
    const arr = Array.from(listEl.children).map(li => ({
      id: li.dataset.id,
      title: li.querySelector('.title').textContent,
      meta: li.querySelector('.meta').textContent
    }));
    const blob = new Blob([JSON.stringify(arr, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'ultra-reorder.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // Reset
  document.getElementById('resetBtn').addEventListener('click', ()=>{
    localStorage.removeItem(KEY);
    render(initial);
  });

  // Drag & Drop implementation (pointer events)
  let dragging = null; // original dragged <li>
  let ghost = null;    // ghost element following pointer
  let placeholder = null;
  let startY = 0;
  let offsetY = 0;
  let pointerId = null;

  function attachBehaviors(){
    // Pointer down on handle starts drag
    const items = listEl.querySelectorAll('li.rli');
    items.forEach(li=>{
      // pointerdown on handle only
      const handle = li.querySelector('[data-handle]');
      handle.addEventListener('pointerdown', (ev) => {
        ev.preventDefault();
        // capture this pointer only
        pointerId = ev.pointerId;
        (ev.target).setPointerCapture(pointerId);
        startDrag(li, ev);
      });

      // keyboard reordering
      li.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          keyboardReorder(li, e.key === 'ArrowUp' ? -1 : 1);
        }
      });

      // visual focus ring for keyboard
      li.addEventListener('focus', ()=> li.classList.add('kbd-focus'));
      li.addEventListener('blur', ()=> li.classList.remove('kbd-focus'));
    });
  }

  function startDrag(li, ev){
    dragging = li;
    dragging.classList.add('li-dragging');

    // create placeholder
    placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    placeholder.style.height = `${dragging.offsetHeight}px`;

    // insert placeholder where the item was
    dragging.after(placeholder);

    // clone ghost
    ghost = dragging.cloneNode(true);
    ghost.classList.add('ghost');
    ghost.style.width = dragging.offsetWidth + 'px';
    ghost.style.left = (ev.clientX - 10) + 'px';
    ghost.style.top = (ev.clientY - 10) + 'px';
    document.body.appendChild(ghost);
    document.documentElement.style.cursor = 'grabbing';

    // compute offset between pointer and top-left of dragging element
    const rect = dragging.getBoundingClientRect();
    offsetY = ev.clientY - rect.top;

    // pointermove & up listeners on document
    const move = (e) => {
      if (e.pointerId !== pointerId) return;
      onPointerMove(e);
    };
    const up = (e) => {
      if (e.pointerId !== pointerId) return;
      endDrag(e);
      document.removeEventListener('pointermove', move);
      document.removeEventListener('pointerup', up);
      document.removeEventListener('pointercancel', up);
    };
    document.addEventListener('pointermove', move);
    document.addEventListener('pointerup', up);
    document.addEventListener('pointercancel', up);
  }

  function onPointerMove(e){
    if (!ghost) return;
    ghost.style.left = (e.clientX - ghost.offsetWidth/2) + 'px';
    ghost.style.top = (e.clientY - offsetY) + 'px';

    // find element under pointer within the list (excluding ghost)
    const children = Array.from(listEl.children).filter(n => n !== dragging && n !== placeholder);
    let found = null;
    for (const child of children) {
      const r = child.getBoundingClientRect();
      if (e.clientY > r.top && e.clientY < r.bottom) {
        found = child;
        // decide whether to insert before or after based on midpoint
        const mid = r.top + r.height/2;
        if (e.clientY < mid) {
          listEl.insertBefore(placeholder, child);
        } else {
          listEl.insertBefore(placeholder, child.nextSibling);
        }
        break;
      }
    }
    // if nothing found (pointer below or above), move placeholder to end/start
    if (!found) {
      const first = listEl.firstElementChild;
      const last = listEl.lastElementChild;
      if (e.clientY < (first ? first.getBoundingClientRect().top : Infinity)) {
        listEl.insertBefore(placeholder, first);
      } else {
        listEl.appendChild(placeholder);
      }
    }
  }

  function endDrag(e){
    if (!dragging) return;
    // place dragging where placeholder is
    listEl.insertBefore(dragging, placeholder);
    dragging.classList.remove('li-dragging');
    // cleanup
    placeholder.remove();
    placeholder = null;
    ghost.remove();
    ghost = null;
    dragging = null;
    pointerId = null;
    document.documentElement.style.cursor = '';
    saveOrder();
  }

  // keyboard reorder: move item up/down by one
  function keyboardReorder(li, dir){
    // dir: -1 up, +1 down
    const target = (dir < 0) ? li.previousElementSibling : li.nextElementSibling;
    if (!target) return;
    if (dir < 0) {
      listEl.insertBefore(li, target);
    } else {
      listEl.insertBefore(target, li);
    }
    li.focus();
    // slight animation
    li.style.transition = 'transform 160ms';
    setTimeout(()=> li.style.transition = '', 200);
    saveOrder();
  }

  // initial render & attach
  render(saved);

  // Accessibility: allow Enter or Space on handle to start keyboard "lift" (optional simple move mode)
  // We also support long-press on touch by pointerdown+timeout (native pointer events handled above),
  // so we avoid separate long-press logic for simplicity.

  // Make the list respond to reordering on drag end even if user drops outside (safety)
  window.addEventListener('blur', () => {
    if (dragging) {
      // attempt to end gracefully at current placeholder
      if (placeholder && dragging) {
        listEl.insertBefore(dragging, placeholder);
        placeholder.remove();
      }
      if (ghost) ghost.remove();
      document.documentElement.style.cursor = '';
      saveOrder();
      dragging && dragging.classList.remove('li-dragging');
      dragging = null; placeholder=null; ghost=null; pointerId=null;
    }
  });

  // keyboard: Ctrl+S to export
  window.addEventListener('keydown', (e)=>{
    if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='s') {
      e.preventDefault();
      document.getElementById('exportBtn').click();
    }
  });

  // small helper: if list is empty create placeholder message
  function ensureNotEmpty(){
    if (!listEl.children.length) {
      const li = document.createElement('li');
      li.className='rli';
      li.style.opacity = .6;
      li.textContent = 'No items';
      listEl.appendChild(li);
    }
  }

  // expose render to window for dev/debug (optional)
  window.ultraReorder = {render, saveOrder};

})();
</script>
</body>
</html>